(ns cascalog.util
  (:use [clojure.set :only (difference)]
        [clojure.tools.macro :only (name-with-attributes)])
  (:require [clojure.string :as s])
  (:import [java.util UUID Collection]))

(defmacro defalias
  "Defines an alias for a var: a new var with the same root binding (if
  any) and similar metadata. The metadata of the alias is its initial
  metadata (as provided by def) merged into the metadata of the original."
  ([name orig]
     `(do
        (alter-meta!
         (if (.hasRoot (var ~orig))
           (def ~name (.getRawRoot (var ~orig)))
           (def ~name))
         ;; When copying metadata, disregard {:macro false}.
         ;; Workaround for http://www.assembla.com/spaces/clojure/tickets/273
         #(conj (dissoc % :macro)
                (apply dissoc (meta (var ~orig)) (remove #{:macro} (keys %)))))
        (var ~name)))
  ([name orig doc]
     (list `defalias (with-meta name (assoc (meta name) :doc doc)) orig)))

(defmacro defnk
 "Define a function accepting keyword arguments. Symbols up to the first
 keyword in the parameter list are taken as positional arguments.  Then
 an alternating sequence of keywords and defaults values is expected. The
 values of the keyword arguments are available in the function body by
 virtue of the symbol corresponding to the keyword (cf. :keys destructuring).
 defnk accepts an optional docstring as well as an optional metadata map."
 [fn-name & fn-tail]
 (let [[fn-name [args & body]] (name-with-attributes fn-name fn-tail)
       [pos kw-vals]           (split-with symbol? args)
       syms                    (map #(-> % name symbol) (take-nth 2 kw-vals))
       values                  (take-nth 2 (rest kw-vals))
       sym-vals                (apply hash-map (interleave syms values))
       sym-vals                (apply dissoc sym-vals (for [[k v] sym-vals
                                                            :when (nil? v)] k))
       de-map                  {:keys (vec syms)
                                :or   sym-vals}]
   `(defn ~fn-name
      [~@pos & ~de-map]
      ~@body)))

(defn multifn? [x]
  (instance? clojure.lang.MultiFn x))

(defn throw-illegal [& xs]
  (throw (IllegalArgumentException. (apply str xs))))

(defn throw-runtime [& xs]
  (throw (RuntimeException. (apply str xs))))

(defn >=s
  ">= for strings."
  [s1 s2]
  (= s2 (first (sort [s1 s2]))))

(defmacro safe-assert
  "TODO: throw a descriptive runtime exception in 1.2 w/ the message."
  ([x] `(safe-assert ~x ""))
  ([x msg]
     (if (>=s (clojure-version) "1.3.0")
       `(assert ~x ~msg)
       `(assert ~x))))

(defn try-update-in
  [m key-vec f & args]
  (reduce #(%2 %1) m
          (for [k key-vec]
            #(if (get % k)
               (apply update-in % [k] f args)
               %))))

(defn merge-to-vec
  "Returns a vector representation of the union of all supplied
  items. Entries in xs can be collections or individual items. For
  example,

  (merge-to-vec [1 2] :help 2 1)
  => [1 2 :help]"
  [& xs]
  (->> xs
       (map #(if (coll? %) (set %) #{%}))
       (reduce #(concat % (difference %2 (set %))))
       (vec)))

(defn transpose [m]
  (apply map list m))

(defn find-first
  "Returns the first item of coll for which (pred item) returns logical true.
  Consumes sequences up to the first match, will consume the entire sequence
  and return nil if no match is found."
  [pred coll]
  (first (filter pred coll)))

(def ^{:doc "Accepts a predicate and a sequence, and returns:

   [(filter pred xs) (remove pred xs)]"}
  separate
  (juxt filter remove))

(defn substitute-if
  "Returns [newseq {map of newvals to oldvals}]"
  [pred subfn aseq]
  (reduce (fn [[newseq subs] val]
            (let [[newval sub] (if (pred val)
                                 (let [subbed (subfn val)] [subbed {subbed val}])
                                 [val {}])]
              [(conj newseq newval) (merge subs sub)]))
          [[] {}] aseq))

(defn try-resolve [obj]
  (cond (symbol? obj) (resolve obj)
        (list? obj) (resolve (first obj))))

(defn wipe
  "Returns a new collection generated by dropping the item at position
  `idx` from `coll`."
  [coll idx]
  (concat (take idx coll) (drop (inc idx) coll)))

(defn collectify [obj]
  (if (or (sequential? obj) (instance? Collection obj)) obj [obj]))

(defn multi-set
  "Returns a map of elem to count"
  [aseq]
  (apply merge-with +
         (map #(hash-map % 1) aseq)))

(defn remove-first [f coll]
  (let [i (map-indexed vector coll)
        ri (find-first #(f (second %)) i)]
    (when-not ri (throw-illegal "Couldn't find an item to remove"))
    (map second (remove (partial = ri) i))))

(defn uuid []
  (str (UUID/randomUUID)))

(defn all-pairs
  "[1 2 3] -> [[1 2] [1 3] [2 3]]"
  [coll]
  (let [pair-up (fn [v vals]
                  (map (partial vector v) vals))]
    (apply concat (for [i (range (dec (count coll)))]
                    (pair-up (nth coll i) (drop (inc i) coll))
                    ))))

(defn unweave
  "[1 2 3 4 5 6] -> [[1 3 5] [2 4 6]]"
  [coll]
  (when (odd? (count coll))
    (throw-illegal "Need even number of args to unweave"))
  [(take-nth 2 coll) (take-nth 2 (rest coll))])

(defn duplicates
  "Returns a vector of all values for which duplicates appear in the
  supplied collection. For example:

  (duplicates [1 2 2 1 3])
  ;=> [1 2]"
  [coll]
  (loop [[x & more] coll, test-set #{}, dups #{}]
    (if-not x
      (vec dups)
      (recur more
             (conj test-set x)
             (if (test-set x) (conj dups x) dups)))))

(defn pairs2map [pairs]
  (apply hash-map (flatten pairs)))

(defn reverse-map
  "{:a 1 :b 1 :c 2} -> {1 [:a :b] 2 :c}"
  [amap]
  (reduce (fn [m [k v]]
            (let [existing (get m v [])]
              (assoc m v (conj existing k))))
          {} amap))

(defn some? [pred coll]
  ((complement nil?) (some pred coll)))

(defmacro dofor [& body]
  `(doall (for ~@body)))

(defn count= [& args]
  (apply = (map count args)))

(defn not-count= [& args]
  (not (apply count= args)))

(defmacro if-ret [form else-form]
  `(if-let [ret# ~form]
     ret#
     ~else-form))

(defn- clean-nil-bindings [bindings]
  (let [pairs (partition 2 bindings)]
    (mapcat identity (filter #(first %) pairs))))

(defn meta-conj
  "Returns the supplied symbol with the supplied `attr` map conj-ed
  onto the symbol's current metadata."
  [sym attr]
  (with-meta sym (if (meta sym)
                   (conj (meta sym) attr)
                   attr)))

(defn meta-dissoc
  [sym & ks]
  (with-meta sym (apply dissoc (meta sym) ks)))

(defn set-namespace-value
  "Merges the supplied kv-pair into the metadata of the namespace in
  which the function is called."
  [key-name newval]
  (alter-meta! *ns* merge {key-name newval}))

(defn mk-destructured-seq-map [& bindings]
  ;; lhs needs to be symbolified
  (let [bindings (clean-nil-bindings bindings)
        to-sym (fn [s] (if (keyword? s) s (symbol s)))
        [lhs rhs] (unweave bindings)
        lhs  (for [l lhs] (if (sequential? l) (vec (map to-sym l)) (symbol l)))
        rhs (for [r rhs] (if (sequential? r) (vec r) r))
        destructured (vec (destructure (interleave lhs rhs)))
        syms (first (unweave destructured))
        extract-code (vec (for [s syms] [(str s) s]))]
    (eval
     `(let ~destructured
        (into {} ~extract-code)))))

(def default-serializations
  ["org.apache.hadoop.io.serializer.WritableSerialization"
   "cascading.tuple.hadoop.BytesSerialization"
   "cascading.tuple.hadoop.TupleSerialization"])

(defn serialization-entry
  [serial-vec]
  (->> serial-vec
       (map (fn [x]
              (cond (string? x) x
                    (class? x) (.getName x))))
       (s/join ",")))

(defn no-empties [s]
  (when s (not= "" s)))

(defn merge-serialization-strings
  [& all]
  (serialization-entry
   (->> (filter no-empties all)
        (map #(s/split % #","))
        (apply merge-to-vec default-serializations))))

;; When some shit comes in, it can be a vector or a string; we want to
;; take EITHER ONE, cut it up 

(defn update-vals [m f]
  (into {} (for [[k v] m] [k (f k v)])))

(defn stringify [x]
  (if (class? x)
    (.getName x)
    (str x)))

(defn resolve-collections [v]
  (->> (collectify v)
       (map stringify)
       (s/join ",")))

(defn adjust-vals [& vals]
  (->> (map resolve-collections vals)
       (apply merge-serialization-strings)))

(defn conf-merge [& ms]
  (->> ms
       (map #(update-vals % (fn [_ v] (resolve-collections v))))
       (reduce merge)))

(defn project-merge [& ms]
  (let [vals (->> (map #(get % "io.serializations") ms)
                  (apply adjust-vals))
        ms (apply conf-merge ms)]
    (assoc ms "io.serializations" vals)))

(defn stringify-keys [m]
  (into {} (for [[k v] m]
             [(if (keyword? k)
                (name k)
                (str k)) v])))

(defn filter-empty-gens [gens]
  (cond (not-any? empty? gens) gens
        (> (count gens) 1) (filter #(not-empty %) gens)
        :else (list [[nil]])))
