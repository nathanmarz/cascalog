<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>cascalog.logic.parse documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Cascalog-core 2.0.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="cascalog.api.html"><span>cascalog.api</span></a></li><li><a href="cascalog.cascading.conf.html"><span>cascalog.cascading.conf</span></a></li><li><a href="cascalog.cascading.flow.html"><span>cascalog.cascading.flow</span></a></li><li><a href="cascalog.cascading.io.html"><span>cascalog.cascading.io</span></a></li><li><a href="cascalog.cascading.operations.html"><span>cascalog.cascading.operations</span></a></li><li><a href="cascalog.cascading.platform.html"><span>cascalog.cascading.platform</span></a></li><li><a href="cascalog.cascading.tap.html"><span>cascalog.cascading.tap</span></a></li><li><a href="cascalog.cascading.types.html"><span>cascalog.cascading.types</span></a></li><li><a href="cascalog.cascading.util.html"><span>cascalog.cascading.util</span></a></li><li><a href="cascalog.logic.algebra.html"><span>cascalog.logic.algebra</span></a></li><li><a href="cascalog.logic.def.html"><span>cascalog.logic.def</span></a></li><li><a href="cascalog.logic.fn.html"><span>cascalog.logic.fn</span></a></li><li><a href="cascalog.logic.ops.html"><span>cascalog.logic.ops</span></a></li><li><a href="cascalog.logic.ops-impl.html"><span>cascalog.logic.ops-impl</span></a></li><li><a href="cascalog.logic.options.html"><span>cascalog.logic.options</span></a></li><li class="current"><a href="cascalog.logic.parse.html"><span>cascalog.logic.parse</span></a></li><li><a href="cascalog.logic.platform.html"><span>cascalog.logic.platform</span></a></li><li><a href="cascalog.logic.predicate.html"><span>cascalog.logic.predicate</span></a></li><li><a href="cascalog.logic.predmacro.html"><span>cascalog.logic.predmacro</span></a></li><li><a href="cascalog.logic.testing.html"><span>cascalog.logic.testing</span></a></li><li><a href="cascalog.logic.vars.html"><span>cascalog.logic.vars</span></a></li><li><a href="cascalog.logic.zip.html"><span>cascalog.logic.zip</span></a></li><li><a href="cascalog.playground.html"><span>cascalog.playground</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="cascalog.logic.parse.html#var--%3EApplication"><span>-&gt;Application</span></a></li><li><a href="cascalog.logic.parse.html#var--%3EExistenceNode"><span>-&gt;ExistenceNode</span></a></li><li><a href="cascalog.logic.parse.html#var--%3EFilterApplication"><span>-&gt;FilterApplication</span></a></li><li><a href="cascalog.logic.parse.html#var--%3EGrouping"><span>-&gt;Grouping</span></a></li><li><a href="cascalog.logic.parse.html#var--%3EJoin"><span>-&gt;Join</span></a></li><li><a href="cascalog.logic.parse.html#var--%3EMerge"><span>-&gt;Merge</span></a></li><li><a href="cascalog.logic.parse.html#var--%3EProjection"><span>-&gt;Projection</span></a></li><li><a href="cascalog.logic.parse.html#var--%3ERename"><span>-&gt;Rename</span></a></li><li><a href="cascalog.logic.parse.html#var--%3ETailStruct"><span>-&gt;TailStruct</span></a></li><li><a href="cascalog.logic.parse.html#var--%3EUnique"><span>-&gt;Unique</span></a></li><li><a href="cascalog.logic.parse.html#var-%3C-"><span>&lt;-</span></a></li><li><a href="cascalog.logic.parse.html#var-IApplyToTail"><span>IApplyToTail</span></a></li><li><a href="cascalog.logic.parse.html#var-accept%3F"><span>accept?</span></a></li><li><a href="cascalog.logic.parse.html#var-add-ops-fixed-point"><span>add-ops-fixed-point</span></a></li><li><a href="cascalog.logic.parse.html#var-aggregation-assertions%21"><span>aggregation-assertions!</span></a></li><li><a href="cascalog.logic.parse.html#var-apply-equality-ops"><span>apply-equality-ops</span></a></li><li><a href="cascalog.logic.parse.html#var-apply-to-tail"><span>apply-to-tail</span></a></li><li><a href="cascalog.logic.parse.html#var-attempt-join"><span>attempt-join</span></a></li><li><a href="cascalog.logic.parse.html#var-build-agg-tail"><span>build-agg-tail</span></a></li><li><a href="cascalog.logic.parse.html#var-build-query"><span>build-query</span></a></li><li><a href="cascalog.logic.parse.html#var-build-rule"><span>build-rule</span></a></li><li><a href="cascalog.logic.parse.html#var-chain"><span>chain</span></a></li><li><a href="cascalog.logic.parse.html#var-default-selector"><span>default-selector</span></a></li><li><a href="cascalog.logic.parse.html#var-desugar-selectors"><span>desugar-selectors</span></a></li><li><a href="cascalog.logic.parse.html#var-existence-branch%3F"><span>existence-branch?</span></a></li><li><a href="cascalog.logic.parse.html#var-existence-field"><span>existence-field</span></a></li><li><a href="cascalog.logic.parse.html#var-expand-outvars"><span>expand-outvars</span></a></li><li><a href="cascalog.logic.parse.html#var-expand-positional-selector"><span>expand-positional-selector</span></a></li><li><a href="cascalog.logic.parse.html#var-find-join-fields"><span>find-join-fields</span></a></li><li><a href="cascalog.logic.parse.html#var-grouping-input"><span>grouping-input</span></a></li><li><a href="cascalog.logic.parse.html#var-grouping-output"><span>grouping-output</span></a></li><li><a href="cascalog.logic.parse.html#var-initial-tails"><span>initial-tails</span></a></li><li><a href="cascalog.logic.parse.html#var-joinable%3F"><span>joinable?</span></a></li><li><a href="cascalog.logic.parse.html#var-map-%3EApplication"><span>map-&gt;Application</span></a></li><li><a href="cascalog.logic.parse.html#var-map-%3EExistenceNode"><span>map-&gt;ExistenceNode</span></a></li><li><a href="cascalog.logic.parse.html#var-map-%3EFilterApplication"><span>map-&gt;FilterApplication</span></a></li><li><a href="cascalog.logic.parse.html#var-map-%3EGrouping"><span>map-&gt;Grouping</span></a></li><li><a href="cascalog.logic.parse.html#var-map-%3EJoin"><span>map-&gt;Join</span></a></li><li><a href="cascalog.logic.parse.html#var-map-%3EMerge"><span>map-&gt;Merge</span></a></li><li><a href="cascalog.logic.parse.html#var-map-%3EProjection"><span>map-&gt;Projection</span></a></li><li><a href="cascalog.logic.parse.html#var-map-%3ERename"><span>map-&gt;Rename</span></a></li><li><a href="cascalog.logic.parse.html#var-map-%3ETailStruct"><span>map-&gt;TailStruct</span></a></li><li><a href="cascalog.logic.parse.html#var-map-%3EUnique"><span>map-&gt;Unique</span></a></li><li><a href="cascalog.logic.parse.html#var-maximal-join"><span>maximal-join</span></a></li><li><a href="cascalog.logic.parse.html#var-merge-tails"><span>merge-tails</span></a></li><li><a href="cascalog.logic.parse.html#var-op-allowed%3F"><span>op-allowed?</span></a></li><li><a href="cascalog.logic.parse.html#var-parse-subquery"><span>parse-subquery</span></a></li><li><a href="cascalog.logic.parse.html#var-parse-variables"><span>parse-variables</span></a></li><li><a href="cascalog.logic.parse.html#var-prefer-filter"><span>prefer-filter</span></a></li><li><a href="cascalog.logic.parse.html#var-prepare-operation"><span>prepare-operation</span></a></li><li><a href="cascalog.logic.parse.html#var-project"><span>project</span></a></li><li><a href="cascalog.logic.parse.html#var-query-signature%3F"><span>query-signature?</span></a></li><li><a href="cascalog.logic.parse.html#var-rename"><span>rename</span></a></li><li><a href="cascalog.logic.parse.html#var-select-join"><span>select-join</span></a></li><li><a href="cascalog.logic.parse.html#var-split-outvar-constants"><span>split-outvar-constants</span></a></li><li><a href="cascalog.logic.parse.html#var-tail-fields-intersection"><span>tail-fields-intersection</span></a></li><li><a href="cascalog.logic.parse.html#var-tail%3F"><span>tail?</span></a></li><li><a href="cascalog.logic.parse.html#var-unground-assertions%21"><span>unground-assertions!</span></a></li><li><a href="cascalog.logic.parse.html#var-unground-outvars"><span>unground-outvars</span></a></li><li><a href="cascalog.logic.parse.html#var-validate-aggregation%21"><span>validate-aggregation!</span></a></li><li><a href="cascalog.logic.parse.html#var-validate-generator-set%21"><span>validate-generator-set!</span></a></li><li><a href="cascalog.logic.parse.html#var-validate-predicates%21"><span>validate-predicates!</span></a></li><li><a href="cascalog.logic.parse.html#var-validate-projection%21"><span>validate-projection!</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>cascalog.logic.parse documentation</h2><pre class="doc"></pre><div class="public" id="var--%3EApplication"><h3>-&gt;Application</h3><div class="usage"><code>(-&gt;Application source operation)</code></div><pre class="doc">Positional factory function for class cascalog.logic.parse.Application.
</pre></div><div class="public" id="var--%3EExistenceNode"><h3>-&gt;ExistenceNode</h3><div class="usage"><code>(-&gt;ExistenceNode source output-field)</code></div><pre class="doc">Positional factory function for class cascalog.logic.parse.ExistenceNode.
</pre></div><div class="public" id="var--%3EFilterApplication"><h3>-&gt;FilterApplication</h3><div class="usage"><code>(-&gt;FilterApplication source filter)</code></div><pre class="doc">Positional factory function for class cascalog.logic.parse.FilterApplication.
</pre></div><div class="public" id="var--%3EGrouping"><h3>-&gt;Grouping</h3><div class="usage"><code>(-&gt;Grouping source aggregators grouping-fields options)</code></div><pre class="doc">Positional factory function for class cascalog.logic.parse.Grouping.
</pre></div><div class="public" id="var--%3EJoin"><h3>-&gt;Join</h3><div class="usage"><code>(-&gt;Join sources join-fields type-seq)</code></div><pre class="doc">Positional factory function for class cascalog.logic.parse.Join.
</pre></div><div class="public" id="var--%3EMerge"><h3>-&gt;Merge</h3><div class="usage"><code>(-&gt;Merge sources)</code></div><pre class="doc">Positional factory function for class cascalog.logic.parse.Merge.
</pre></div><div class="public" id="var--%3EProjection"><h3>-&gt;Projection</h3><div class="usage"><code>(-&gt;Projection source fields)</code></div><pre class="doc">Positional factory function for class cascalog.logic.parse.Projection.
</pre></div><div class="public" id="var--%3ERename"><h3>-&gt;Rename</h3><div class="usage"><code>(-&gt;Rename source fields)</code></div><pre class="doc">Positional factory function for class cascalog.logic.parse.Rename.
</pre></div><div class="public" id="var--%3ETailStruct"><h3>-&gt;TailStruct</h3><div class="usage"><code>(-&gt;TailStruct node ground? available-fields operations)</code></div><pre class="doc">Positional factory function for class cascalog.logic.parse.TailStruct.
</pre></div><div class="public" id="var--%3EUnique"><h3>-&gt;Unique</h3><div class="usage"><code>(-&gt;Unique source fields options)</code></div><pre class="doc">Positional factory function for class cascalog.logic.parse.Unique.
</pre></div><div class="public" id="var-%3C-"><h3>&lt;-</h3><h4 class="macro">macro</h4><div class="usage"><code>(&lt;- outvars &amp; predicates)</code></div><pre class="doc">Constructs a query or predicate macro from a list of
predicates. Predicate macros support destructuring of the input and
output variables.</pre></div><div class="public" id="var-IApplyToTail"><h3>IApplyToTail</h3><div class="usage"></div><pre class="doc"></pre></div><div class="public" id="var-accept%3F"><h3>accept?</h3><div class="usage"><code>(accept? this tail)</code></div><pre class="doc">Returns true if this op can be applied to the current tail
</pre></div><div class="public" id="var-add-ops-fixed-point"><h3>add-ops-fixed-point</h3><div class="usage"><code>(add-ops-fixed-point tail)</code></div><pre class="doc">Adds operations to tail until can't anymore. Returns new tail and
any unapplied operations.</pre></div><div class="public" id="var-aggregation-assertions%21"><h3>aggregation-assertions!</h3><div class="usage"><code>(aggregation-assertions! buffers aggs options)</code></div><pre class="doc"></pre></div><div class="public" id="var-apply-equality-ops"><h3>apply-equality-ops</h3><div class="usage"><code>(apply-equality-ops tail equality-pairs)</code></div><pre class="doc">Accepts a TailStruct instance and a sequence of pairs of input
variables, and applies an equality filter for every pair.</pre></div><div class="public" id="var-apply-to-tail"><h3>apply-to-tail</h3><div class="usage"><code>(apply-to-tail this tail)</code></div><pre class="doc">Accepts a tail and performs some modification on that tail,
returning a new tail.</pre></div><div class="public" id="var-attempt-join"><h3>attempt-join</h3><div class="usage"><code>(attempt-join tails)</code></div><pre class="doc">Attempt to reduce the supplied set of tails by joining.
</pre></div><div class="public" id="var-build-agg-tail"><h3>build-agg-tail</h3><div class="usage"><code>(build-agg-tail tail aggs grouping-fields options)</code></div><pre class="doc"></pre></div><div class="public" id="var-build-query"><h3>build-query</h3><div class="usage"><code>(build-query output-fields raw-predicates)</code></div><pre class="doc"></pre></div><div class="public" id="var-build-rule"><h3>build-rule</h3><div class="usage"><code>(build-rule {:keys [fields predicates options], :as input})</code></div><pre class="doc"></pre></div><div class="public" id="var-chain"><h3>chain</h3><div class="usage"><code>(chain tail f)</code></div><pre class="doc"></pre></div><div class="public" id="var-default-selector"><h3>default-selector</h3><div class="usage"><code>(default-selector op)</code></div><pre class="doc">Default selector (either input or output) for this
operation. Dispatches based on type.</pre></div><div class="public" id="var-desugar-selectors"><h3>desugar-selectors</h3><div class="usage"><code>(desugar-selectors arg-m &amp; sugar-full-pairs)</code></div><pre class="doc">Accepts a map of cascalog input or output symbol (:&lt; or :&gt;, for
 example) to var sequence, a &lt;sugary input or output selector&gt; and a
 &lt;full vector input or output selector&gt; and either destructures the
 non-sugary input or moves the sugary input into its proper
 place. For example:

(desugar-selectors {:&gt;&gt; ([&quot;?a&quot;])} :&gt; :&gt;&gt;)
;=&gt; {:&gt;&gt; [&quot;?a&quot;]}

(desugar-selectors {:&gt; [&quot;?a&quot;] :&lt;&lt; [[&quot;?b&quot;]]} :&gt; :&gt;&gt; :&lt; :&lt;&lt;)
;=&gt;  {:&gt;&gt; [&quot;?a&quot;], :&lt;&lt; [&quot;?b&quot;]}</pre></div><div class="public" id="var-existence-branch%3F"><h3>existence-branch?</h3><div class="usage"></div><pre class="doc"></pre></div><div class="public" id="var-existence-field"><h3>existence-field</h3><div class="usage"><code>(existence-field node)</code></div><pre class="doc">Returns true if this location directly descends from an
ExistenceNode, false otherwise. Short-circuits at any merge.</pre></div><div class="public" id="var-expand-outvars"><h3>expand-outvars</h3><div class="usage"><code>(expand-outvars {:keys [op input output], :as pred})</code></div><pre class="doc"></pre></div><div class="public" id="var-expand-positional-selector"><h3>expand-positional-selector</h3><div class="usage"><code>(expand-positional-selector arg-m)</code></div><pre class="doc">Accepts a map of cascalog selector to var sequence and, if the map
contains an entry for Cascalog's positional selector, expands out
the proper number of logic vars and replaces each entry specified
within the positional map. This function returns the updated map.</pre></div><div class="public" id="var-find-join-fields"><h3>find-join-fields</h3><div class="usage"><code>(find-join-fields l r)</code></div><pre class="doc"></pre></div><div class="public" id="var-grouping-input"><h3>grouping-input</h3><div class="usage"><code>(grouping-input aggs sort-fields)</code></div><pre class="doc">These are the operations that go into the aggregators.
</pre></div><div class="public" id="var-grouping-output"><h3>grouping-output</h3><div class="usage"><code>(grouping-output aggs grouping-fields)</code></div><pre class="doc">Returns the union of all grouping fields and all outputs for every
aggregation field. These are the only fields available after the
aggregation.</pre></div><div class="public" id="var-initial-tails"><h3>initial-tails</h3><div class="usage"><code>(initial-tails generators operations)</code></div><pre class="doc">Builds up a sequence of tail structs from the supplied generators
and operations.</pre></div><div class="public" id="var-joinable%3F"><h3>joinable?</h3><div class="usage"><code>(joinable? tail joinfields)</code></div><pre class="doc">Returns true if the supplied tail can be joined with the supplied
join fields, false otherwise.

A join works if the join fields are all available in the given tail
AND the tail's either fully ground, or every non-join variable is
unground.</pre></div><div class="public" id="var-map-%3EApplication"><h3>map-&gt;Application</h3><div class="usage"><code>(map-&gt;Application m__2313__auto__)</code></div><pre class="doc">Factory function for class cascalog.logic.parse.Application, taking a map of keywords to field values.
</pre></div><div class="public" id="var-map-%3EExistenceNode"><h3>map-&gt;ExistenceNode</h3><div class="usage"><code>(map-&gt;ExistenceNode m__2313__auto__)</code></div><pre class="doc">Factory function for class cascalog.logic.parse.ExistenceNode, taking a map of keywords to field values.
</pre></div><div class="public" id="var-map-%3EFilterApplication"><h3>map-&gt;FilterApplication</h3><div class="usage"><code>(map-&gt;FilterApplication m__2313__auto__)</code></div><pre class="doc">Factory function for class cascalog.logic.parse.FilterApplication, taking a map of keywords to field values.
</pre></div><div class="public" id="var-map-%3EGrouping"><h3>map-&gt;Grouping</h3><div class="usage"><code>(map-&gt;Grouping m__2313__auto__)</code></div><pre class="doc">Factory function for class cascalog.logic.parse.Grouping, taking a map of keywords to field values.
</pre></div><div class="public" id="var-map-%3EJoin"><h3>map-&gt;Join</h3><div class="usage"><code>(map-&gt;Join m__2313__auto__)</code></div><pre class="doc">Factory function for class cascalog.logic.parse.Join, taking a map of keywords to field values.
</pre></div><div class="public" id="var-map-%3EMerge"><h3>map-&gt;Merge</h3><div class="usage"><code>(map-&gt;Merge m__2313__auto__)</code></div><pre class="doc">Factory function for class cascalog.logic.parse.Merge, taking a map of keywords to field values.
</pre></div><div class="public" id="var-map-%3EProjection"><h3>map-&gt;Projection</h3><div class="usage"><code>(map-&gt;Projection m__2313__auto__)</code></div><pre class="doc">Factory function for class cascalog.logic.parse.Projection, taking a map of keywords to field values.
</pre></div><div class="public" id="var-map-%3ERename"><h3>map-&gt;Rename</h3><div class="usage"><code>(map-&gt;Rename m__2313__auto__)</code></div><pre class="doc">Factory function for class cascalog.logic.parse.Rename, taking a map of keywords to field values.
</pre></div><div class="public" id="var-map-%3ETailStruct"><h3>map-&gt;TailStruct</h3><div class="usage"><code>(map-&gt;TailStruct m__2313__auto__)</code></div><pre class="doc">Factory function for class cascalog.logic.parse.TailStruct, taking a map of keywords to field values.
</pre></div><div class="public" id="var-map-%3EUnique"><h3>map-&gt;Unique</h3><div class="usage"><code>(map-&gt;Unique m__2313__auto__)</code></div><pre class="doc">Factory function for class cascalog.logic.parse.Unique, taking a map of keywords to field values.
</pre></div><div class="public" id="var-maximal-join"><h3>maximal-join</h3><div class="usage"><code>(maximal-join tail-seq)</code></div><pre class="doc">Returns the between the two generators with the largest
intersection of joinable fields.</pre></div><div class="public" id="var-merge-tails"><h3>merge-tails</h3><div class="usage"><code>(merge-tails tails)</code></div><pre class="doc">The first call begins with a bunch of generator tails, each with a
list of operations that could be applied. Based on the op-allowed
logic, these tails try to consume as many operations as possible
before giving up at a fixed point.</pre></div><div class="public" id="var-op-allowed%3F"><h3>op-allowed?</h3><div class="usage"><code>(op-allowed? {:keys [ground? available-fields node]} op)</code></div><pre class="doc">An operation can be applied to a tail if all of the following
conditions apply:

- It only consumes fields that are available in the supplied
TailStruct,

- It's a filter (or the branch is NOT a GeneratorSet)

- It only consumes ground variables (or the generator itself is
ground)</pre></div><div class="public" id="var-parse-subquery"><h3>parse-subquery</h3><div class="usage"><code>(parse-subquery output-fields raw-predicates)</code></div><pre class="doc">Parses predicates and output fields and returns a proper subquery.
</pre></div><div class="public" id="var-parse-variables"><h3>parse-variables</h3><div class="usage"><code>(parse-variables vars default-selector)</code></div><pre class="doc">parses variables of the form ['?a' '?b' :&gt; '!!c'] and returns a map
of input variables, output variables, If there is no :&gt;, defaults
to selector-default.</pre></div><div class="public" id="var-prefer-filter"><h3>prefer-filter</h3><div class="usage"><code>(prefer-filter op)</code></div><pre class="doc"></pre></div><div class="public" id="var-prepare-operation"><h3>prepare-operation</h3><div class="usage"><code>(prepare-operation op tail)</code></div><pre class="doc">When an operation produces fields that are already present in the
tail, this is interpreted as an implicit filter against the existing
values. This function accepts an operation and a TailStruct and
returns a sequence of all pairs of output variable substitutions,
plus a new operation with output fields swapped as necessary</pre></div><div class="public" id="var-project"><h3>project</h3><div class="usage"><code>(project tail fields)</code></div><pre class="doc"></pre></div><div class="public" id="var-query-signature%3F"><h3>query-signature?</h3><div class="usage"><code>(query-signature? vars)</code></div><pre class="doc">Accepts the normalized return vector of a Cascalog form and returns
true if the return vector is from a subquery, false otherwise. (A
predicate macro would trigger false, for example.)</pre></div><div class="public" id="var-rename"><h3>rename</h3><div class="usage"><code>(rename tail fields)</code></div><pre class="doc"></pre></div><div class="public" id="var-select-join"><h3>select-join</h3><div class="usage"><code>(select-join tails)</code></div><pre class="doc">Returns the join fields that will join the maximum number of fields
at a time. If the search fails, select-join throws.

 This is unoptimal. It's better to rewrite this as a search problem
 to find optimal joins.</pre></div><div class="public" id="var-split-outvar-constants"><h3>split-outvar-constants</h3><div class="usage"><code>(split-outvar-constants output)</code></div><pre class="doc">Accepts a sequence of output variables and returns a 2-vector:

[new-outputs, [seq-of-new-raw-predicates]]

By creating a new output predicate for every constant in the output
field.</pre></div><div class="public" id="var-tail-fields-intersection"><h3>tail-fields-intersection</h3><div class="usage"><code>(tail-fields-intersection &amp; tails)</code></div><pre class="doc"></pre></div><div class="public" id="var-tail%3F"><h3>tail?</h3><div class="usage"></div><pre class="doc">Returns true if the supplied item is a TailStruct, false
otherwise.</pre></div><div class="public" id="var-unground-assertions%21"><h3>unground-assertions!</h3><div class="usage"><code>(unground-assertions! gens ops)</code></div><pre class="doc">Performs various validations on the supplied set of parsed
predicates. If all validations pass, returns the sequence
unchanged.</pre></div><div class="public" id="var-unground-outvars"><h3>unground-outvars</h3><div class="usage"><code>(unground-outvars predicates)</code></div><pre class="doc">For the supplied sequence of RawPredicate instances, returns a seq
of all ungrounding vars in the output position.</pre></div><div class="public" id="var-validate-aggregation%21"><h3>validate-aggregation!</h3><div class="usage"><code>(validate-aggregation! tail aggs options)</code></div><pre class="doc">Makes sure that all fields are available for the aggregation.
</pre></div><div class="public" id="var-validate-generator-set%21"><h3>validate-generator-set!</h3><div class="usage"><code>(validate-generator-set! input output)</code></div><pre class="doc">GeneratorSets can't be unground, ever.
</pre></div><div class="public" id="var-validate-predicates%21"><h3>validate-predicates!</h3><div class="usage"><code>(validate-predicates! preds opts)</code></div><pre class="doc"></pre></div><div class="public" id="var-validate-projection%21"><h3>validate-projection!</h3><div class="usage"><code>(validate-projection! remaining-ops needed available)</code></div><pre class="doc"></pre></div></div></body></html>